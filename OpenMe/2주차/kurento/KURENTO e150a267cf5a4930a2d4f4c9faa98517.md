# KURENTO

### WebRTC란?

- **참조링크**
    
    [https://gocoder.tistory.com/1928](https://gocoder.tistory.com/1928)
    
    [https://webrtc.org/](https://webrtc.org/)
    
    [https://www.cometchat.com/blog/webrtc-101-everything-you-need-to-know](https://www.cometchat.com/blog/webrtc-101-everything-you-need-to-know)
    

> 웹브라우저만으로 플러그인 도움 없이 실시간으로 고품질 커뮤니케이션 기술로, 영상, 음성 및 데이터 통신을 하는 자바스크립트 API이다.
> 
- **장점**
    - Latency가 짧다 : RTMP보다 짧은 Latancy를 가지고 있어 지연시간이 거의 없는 방송을 할 수 있다.(RTMP사용서비스 : 인스타, 유튜브, 트위치 등)
    - 별다른 소프트웨어없이 실시간 커뮤니티가 가능하다.
    - 개발에 있어 진입장벽이 낮다
    - 무료다
- **단점**
    - 크로스브라우징 : 지원하는 브라우저가 적다
    - STUN/TURN서버필요 : 방화벽문제 때문에 다른 네트워크끼리 통신을 위해 STUN/TURN서버를 설치 후 사용해야 한다.
- **NAT(Network Address Translation)**
    
    > Private IP를 Public IP로 변환해주는 장치. 다양한 IP(고정IP,유동IP, PrivateIP 등)를 사용하는 클라이언트를 구분할 수 있도록 Private IP와 Public IP를 1대1 대응시켜준다.
    > 
- **ICE(Interactive Connentivity Establishment)**
    
    > ICE는 두 단말이 서로 통신할 수 있는 최적의 경로를 찾을 수 있도록 도와주는 프레임워크. TURN, STUN서버를 사용해 최적의 경로를 찾는다.
    > 
- **STUN(Session Traversal Utilities for NAT)**
    
    > 공개주소를 발견하거나 Peer간의 직접 연결을 막는 등 라우터의 제한을 결정하며 ICE를 보완하는 프로토콜 → **해당 Peer의 공인 IP 주소를 보내는 역할**을 한다.
    > 
    - 두 엔드 포인트간의 연결을 확인하고 NAT바인딩을 유지하기 위한 연결유지 프로토콜로 사용할 수 있다.
    - 두 단말이 같은 NAT환경에 있거나 NAT보안정책이 엄격할 경우 STUN이 효과적이지 않을 수 있다.
- **TURN(Traversal Using Relays around NAT)**
    
    > TURN서버는 인터넷망에 위치하고 각 Peer(단말)들이 사설망 안에서 통신한다. 각 Peer들이 릴레이 역할을 하는 TURN서버를 사용하여 경유한다.(직접통신 X)
    > 
    - STUN의 확장
    - NAT의 보안정책이 너무 엄격하거나 NAT순회를 위해 필요한 NAT바인딩을 성공적으로 생성할 수 없는 경우 사용
    - STUN에 비해 리소스낭비가 심하다.
    - 때문에, ICE Candidate과정에서 모든 후보군을 찾은 후 최후의 수단으로 사용한다.
- 

### Kurento란?

- **참조링크**
    
    [https://gh402.tistory.com/43?category=935378](https://gh402.tistory.com/43?category=935378)
    
    [https://doc-kurento.readthedocs.io/en/latest/user/intro.html](https://doc-kurento.readthedocs.io/en/latest/user/intro.html)
    

> 전체 WebRTC 스택의 기능적 구현을 제공하는 미디어 서버이다.
> 
- **Kurento특징**
    1. **모듈식 파이프라인**
        
        Kurento는 **WebRTC** 및 **RTP** 발신자 및 수신자, 오디오/비디오 **믹서** , **미디어 녹음** 등과 같은 빌딩 블록 제공 
        
        미디어가 이미 흐르는 경우에도 언제든지 삽입, 활성화 또는 비활성화 하여 **구성** 하기 쉽다.
        
        **또한 Kurento를 확장** 하고 자신만의 요소를 작성 하는 것도 매우 쉽습니다. 그러면 이미 존재하는 요소와 통합될 수 있습니다!
        
        애플리케이션 개발자는 Kurento를 사용하여 원하는 미디어 요소로 소위 *미디어 파이프라인* 을 제어 하여 필요에 맞게 완전히 맞춤화된 아키텍처를 효과적으로 형성합니다. **그룹 통신** , 미디어 형식 **트랜스코딩** 및 시청각 흐름 **라우팅** 을 위해 여러 내장 모듈이 제공됩니다 .
        
        Kurento가 제공하는 유연한 모듈식 접근 방식을 고려할 때 *SFU* ( **Selective Forwarding Unit** ) 및 *MCU* ( **Multipoint Conferencing Unit** ) 애플리케이션 아키텍처를 모두 달성할 수 있습니다.
        
    2. **내장 모듈**
        
        Kurento는 API의 일부로 미디어 요소의 풍부한 도구 상자를 노출합니다.
        
        ![https://doc-kurento.readthedocs.io/en/latest/_images/kurento-toolbox-basic.png](https://doc-kurento.readthedocs.io/en/latest/_images/kurento-toolbox-basic.png)
        
        *Kurento에서 기본 제공되는 일부 미디어 요소*
        
        예를 들어:
        
        - WebRtcEndpoint 는 [WebRTC](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-WebRTC) 미디어 스트림 을 보내고 받을 수 **있습니다 .**
        - **PlayerEndpoint 는 RTSP** , **HTTP** 또는 로컬 소스 에서 미디어를 사용하는 데 사용할 수 있습니다 .
        - **RecorderEndpoint** 는 미디어 스트림을 로컬 또는 원격 파일 시스템에 저장할 수 있습니다.
        - **FaceOverlayFilter** 는 비디오 스트림에서 사람의 얼굴을 감지하여 그 위에 오버레이 이미지를 추가하는 간단한 Computer Vision 예제입니다.
        
        kurento로 구축된 애플리케이션에서 사용되는 이러한 모든 요소의 실제 예를 보려면 [자습서](https://doc-kurento.readthedocs.io/en/latest/user/tutorials.html) 로 바로 이동 하십시오.
        
        자세히 알아보려면 [Kurento 모듈](https://doc-kurento.readthedocs.io/en/latest/features/kurento_modules.html) 에 대한 섹션을 읽으십시오 . 또한, Kurento에는 [자신만의 모듈을 작성할](https://doc-kurento.readthedocs.io/en/latest/user/writing_modules.html) 수 있는 플러그인 API가 있다는 것을 기억하십시오 !
        
    3. **JSON-RPC 프로토콜**
        
        KMS는 WebSocket 연결을 통해 직접 액세스할 수 있는 [Kurento Protocol](https://doc-kurento.readthedocs.io/en/latest/features/kurento_protocol.html) 이라는 JSON-RPC 프로토콜을 통해 모든 API 기능을 노출합니다 . 편의를 위해 Kurento는 Java 및 JavaScript SDK: [클라이언트 API 참조](https://doc-kurento.readthedocs.io/en/latest/features/kurento_client.html) 도 제공합니다 . 그러나 프로토콜에 대해 직접 코드를 작성하기 만 하면 **모든 프로그래밍 언어** 를 사용할 수 있습니다 .
        
        아래 그림은 세 가지 시나리오에서 Kurento를 사용하는 방법을 보여줍니다.
        
        - WebRTC 브라우저에서 직접 Kurento JavaScript SDK 사용(프로덕션 서비스가 아닌 빠른 테스트 및 개발에만 권장됨).
        - 독립 실행형 Java EE 애플리케이션 서버에서 Kurento Java SDK 사용. 웹 브라우저는 HTML 및 [WebRTC](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-WebRTC) 시그널링과 같은 이 애플리케이션의 클라이언트인 반면 애플리케이션 자체는 KMS의 클라이언트입니다(KMS를 제어하기 위해 Kurento 프로토콜 사용).
        - Node.js 애플리케이션 서버에서 Kurento JavaScript SDK 사용. 다시 말하지만, 웹 브라우저는 이 애플리케이션의 클라이언트이고 애플리케이션은 KMS의 클라이언트입니다.
        
        ![https://doc-kurento.readthedocs.io/en/latest/_images/kurento-clients-connection.png](https://doc-kurento.readthedocs.io/en/latest/_images/kurento-clients-connection.png)
        
        *Kurento Media Server에 Kurento Java 및 JavaScript SDK 연결*
        
        지원되는 SDK 기술에 대한 전체 예제는 [자습서](https://doc-kurento.readthedocs.io/en/latest/user/tutorials.html) 에 설명되어 있습니다.
        
- **Kurento를 사용할 수 있는 3가지 방법**
    1. 웹소켓 브라우저로부터 직접적으로 Kurento JavaScript SDK 사용하기(빠르게 테스트할때 추천)
    2. JavaEE 서버에서 Kurento Java SDK를 사용하기(웹브라우저는 HTML, WebRTC시그널링과 같은 작업을 위한 애플리케이션의 클라이언트)
    3. Node.js에 Kurento JavaScript SDK를 사용하기
- **Media Server를 왜사용하는가?**
    
    [WebRTC](https://webrtc.org/) 는 웹 브라우저와 모바일 애플리케이션에 피어 투 피어 연결을 통해 실시간 통신(RTC) 기능을 제공하는 일련의 프로토콜 및 API입니다. 중간 도우미나 서비스 없이 브라우저를 연결할 수 있도록 고안되었지만 실제로 이 P2P 모델은 더 복잡한 응용 프로그램을 만들려고 할 때 부족합니다. 이러한 이유로 대부분의 경우 중앙 미디어 서버가 필요합니다.
    
    ![https://doc-kurento.readthedocs.io/en/latest/_images/media-server-intro.png](https://doc-kurento.readthedocs.io/en/latest/_images/media-server-intro.png)
    
    *P2P WebRTC 접근과 미디어 서버를 통한 WebRTC 비교*
    
    개념적으로 WebRTC 미디어 서버는 소스에서 대상으로 이동할 때 미디어 트래픽이 통과하는 멀티미디어 미들웨어입니다.
    
- **Media Server는 어떤 기능을 제공하는가?**
    
    미디어 서버는 들어오는 미디어 스트림을 처리할 수 있으며 다음과 같은 다양한 결과를 제공합니다.
    
    - 그룹 통신(Group Communications): 한 피어가 생성하는 미디어 스트림을 여러 수신기에 배포하는 것, 즉 다중 회의 장치("MCU") 역할을 합니다.
    - 혼합(Mixing): 여러 수신 스트림을 하나의 단일 복합 스트림으로 변환합니다.
    - 트랜스코딩(Transcoding): 호환되지 않는 클라이언트 간에 코덱 및 형식을 즉시 적용합니다.
    - 녹음(Recording): 피어 간에 교환되는 미디어를 지속적으로 저장합니다.
    
    ![https://doc-kurento.readthedocs.io/en/latest/_images/media-server-capabilities.png](https://doc-kurento.readthedocs.io/en/latest/_images/media-server-capabilities.png)
    
    *일반적인 WebRTC 미디어 서버 기능*
    
- **KMS(Kurento Media Service)가 제공하는 기능**
    
    **KMS( Kurento Media Server** )는 *WebRTC 미디어 서버* 모델에서 사용하여 미디어 전송, 처리, 녹음 및 재생을 허용할 수 있습니다. KMS는 환상적인 [GStreamer](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-GStreamer) 멀티미디어 라이브러리를 기반으로 구축되었으며 다음과 같은 기능을 제공합니다.
    
    - [HTTP](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-HTTP) , [RTP](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-RTP) 및 [WebRTC](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-WebRTC) 를 포함한 네트워크 스트리밍 프로토콜 .
    - 미디어 믹싱 및 미디어 라우팅/디스패칭을 지원하는 그룹 통신( MCU *및 SFU 기능 모두 ).*
    - **Computer Vision** 및 **Augmented Reality** 알고리즘 을 구현하는 필터에 대한 일반 지원 .
    - [WebM](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-WebM) 및 [MP4](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-MP4) *에 대한 쓰기 작업과 GStreamer* 에서 지원하는 모든 형식의 재생 을 지원하는 미디어 저장소입니다 .
    - VP8, H.264, H.263, AMR, OPUS, Speex, G.711 등을 포함하여 GStreamer에서 지원하는 모든 코덱 간의 자동 미디어 트랜스코딩.
    
    ![https://doc-kurento.readthedocs.io/en/latest/_images/kurento-media-server-intro.png](https://doc-kurento.readthedocs.io/en/latest/_images/kurento-media-server-intro.png)
    
    *Kurento 미디어 서버 기능*
    
- **Kurento디자인 원리**
    
    Kurento는 다음과 같은 주요 원칙에 따라 설계되었습니다.
    
    > 미디어 및 애플리케이션 서비스 배포Kurento Media Server 및 애플리케이션은 다른 시스템에 배포, 에스컬레이션 또는 배포될 수 있습니다.단일 애플리케이션은 둘 이상의 Kurento Media Server의 서비스를 호출할 수 있습니다. 그 반대도 적용됩니다. 즉, Kurento Media Server는 둘 이상의 애플리케이션 요청에 참석할 수 있습니다.클라우드에 적합Kurento는 클라우드 환경에 통합되어 PaaS(Platform as a Service) 구성 요소로 작동하는 데 적합합니다.미디어 파이프라인미디어 파이프라인 을 통해 미디어 요소 를 연결 하는 것은 멀티미디어 처리의 복잡성에 도전하는 직관적인 접근 방식입니다.응용 프로그램 개발개발자는 내부 Kurento Media Server 복잡성을 알 필요가 없습니다. 모든 애플리케이션은 클라이언트에서 서버에 이르기까지 개발자가 좋아하는 모든 기술이나 프레임워크에 배포할 수 있습니다. 브라우저에서 클라우드 서비스까지.종단 간 통신 기능Kurento는 종단 간 통신 기능을 제공하므로 개발자는 클라이언트 장치에서 미디어 전송, 인코딩/디코딩 및 렌더링의 복잡성을 처리할 필요가 없습니다.완전히 처리 가능한 미디어 스트림Kurento는 대화형 대인 통신(예: Skype와 같은 대화식 통화 푸시/수신 기능)뿐만 아니라 인간 대 기계(예: 실시간 스트리밍을 통한 주문형 비디오) 및 기계 대 기계(예: 원격 비디오 녹화)를 가능하게 합니다. , 다감각 데이터 교환) 통신.미디어의 모듈식 처리미디어 요소 와 파이프라인 을 통해 모듈화를 달성 하면 "그래프 지향" 언어를 통해 애플리케이션의 미디어 처리 기능을 정의할 수 있습니다. 여기서 애플리케이션 개발자는 적절한 기능을 연결하여 원하는 로직을 생성할 수 있습니다.감사 가능한 처리Kurento는 QoS 모니터링, 청구 및 감사를 위한 풍부하고 상세한 정보를 생성할 수 있습니다.원활한 IMS 통합Kurento는 Telephony Carriers의 IMS 인프라 로의 원활한 통합을 지원하도록 설계되었습니다 .투명 미디어 적응 계층Kurento는 화면 크기, 전력 소비, 전송 속도 등의 요구 사항이 서로 다른 여러 장치 간의 컨버전스를 가능하게 하는 투명한 미디어 적응 계층을 제공합니다.
    > 

### Docker로 실행시키기

- 참조링크
    - [https://doc-kurento.readthedocs.io/en/stable/tutorials/java/tutorial-helloworld.html](https://doc-kurento.readthedocs.io/en/stable/tutorials/java/tutorial-helloworld.html)
    - [https://gh402.tistory.com/44?category=935378](https://gh402.tistory.com/44?category=935378)
1. 쿠렌토 이미지 받아오기

```jsx
sudo docker pull kurento/kurento-media-server:latest
```

1. 이미지 실행시키기 (+포트설정)

```jsx
sudo docker run --rm -p 8888:8888/tcp -p 5000-5050:5000-5050/udp -e KMS_MIN_PORT=5000 -e KMS_MAX_PORT=5050 kurento/kurento-media-server:latest
```

1. git에서 kurento tutorial clone하기

```jsx
git clone https://github.com/Kurento/kurento-tutorial-java.git
```

1. tutorial코드 실행

```jsx
cd kurento-tutorial-java/kurento-hello-world
git checkout 6.16.0
mvn -U clean spring-boot:run \
    -Dspring-boot.run.jvmArguments="-Dkms.url=ws://{KMS_HOST}:8888/kurento"
```

1. [https://localhost:8443/](https://localhost:8443/) 로 접속

![Untitled](KURENTO%20e150a267cf5a4930a2d4f4c9faa98517/Untitled.png)

### STUN/TURN 서버설치

1. 인바운드 포트허용

```jsx
//tcp경우
iptables -I INPUT 1 -p tcp --dport 3478 -j ACCEPT

//udp경우
iptables -I INPUT 1 -p udp --dport 3478 -j ACCEPT
```

1. Coturn 설치

```jsx
sudo apt-get update && sudo apt-get install --no-install-recommends --yes coturn
```

1. Coturn설정

```jsx

```

1. Coturn 재가동

```jsx
sudo service coturn restart
```