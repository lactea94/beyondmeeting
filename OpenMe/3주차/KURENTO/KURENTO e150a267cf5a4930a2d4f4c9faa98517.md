# KURENTO

### WebRTC란?

- **참조링크**
    
    [https://gocoder.tistory.com/1928](https://gocoder.tistory.com/1928)
    
    [https://webrtc.org/](https://webrtc.org/)
    
    [https://www.cometchat.com/blog/webrtc-101-everything-you-need-to-know](https://www.cometchat.com/blog/webrtc-101-everything-you-need-to-know)
    

> 웹브라우저만으로 플러그인 도움 없이 실시간으로 고품질 커뮤니케이션 기술로, 영상, 음성 및 데이터 통신을 하는 자바스크립트 API이다.
> 
- **장점**
    - Latency가 짧다 : RTMP보다 짧은 Latancy를 가지고 있어 지연시간이 거의 없는 방송을 할 수 있다.(RTMP사용서비스 : 인스타, 유튜브, 트위치 등)
    - 별다른 소프트웨어없이 실시간 커뮤니티가 가능하다.
    - 개발에 있어 진입장벽이 낮다
    - 무료다
- **단점**
    - 크로스브라우징 : 지원하는 브라우저가 적다
    - STUN/TURN서버필요 : 방화벽문제 때문에 다른 네트워크끼리 통신을 위해 STUN/TURN서버를 설치 후 사용해야 한다.
- **NAT(Network Address Translation)**
    
    > Private IP를 Public IP로 변환해주는 장치. 다양한 IP(고정IP,유동IP, PrivateIP 등)를 사용하는 클라이언트를 구분할 수 있도록 Private IP와 Public IP를 1대1 대응시켜준다.
    > 
- **ICE(Interactive Connentivity Establishment)**
    
    > ICE는 두 단말이 서로 통신할 수 있는 최적의 경로를 찾을 수 있도록 도와주는 프레임워크. TURN, STUN서버를 사용해 최적의 경로를 찾는다.
    > 
- **STUN(Session Traversal Utilities for NAT)**
    
    > 공개주소를 발견하거나 Peer간의 직접 연결을 막는 등 라우터의 제한을 결정하며 ICE를 보완하는 프로토콜 → **해당 Peer의 공인 IP 주소를 보내는 역할**을 한다.
    > 
    - 두 엔드 포인트간의 연결을 확인하고 NAT바인딩을 유지하기 위한 연결유지 프로토콜로 사용할 수 있다.
    - 두 단말이 같은 NAT환경에 있거나 NAT보안정책이 엄격할 경우 STUN이 효과적이지 않을 수 있다.
- **TURN(Traversal Using Relays around NAT)**
    
    > TURN서버는 인터넷망에 위치하고 각 Peer(단말)들이 사설망 안에서 통신한다. 각 Peer들이 릴레이 역할을 하는 TURN서버를 사용하여 경유한다.(직접통신 X)
    > 
    - STUN의 확장
    - NAT의 보안정책이 너무 엄격하거나 NAT순회를 위해 필요한 NAT바인딩을 성공적으로 생성할 수 없는 경우 사용
    - STUN에 비해 리소스낭비가 심하다.
    - 때문에, ICE Candidate과정에서 모든 후보군을 찾은 후 최후의 수단으로 사용한다.
- 

### Kurento란?

- **참조링크**
    
    [https://gh402.tistory.com/43?category=935378](https://gh402.tistory.com/43?category=935378)
    
    [https://doc-kurento.readthedocs.io/en/latest/user/intro.html](https://doc-kurento.readthedocs.io/en/latest/user/intro.html)
    

> 전체 WebRTC 스택의 기능적 구현을 제공하는 미디어 서버이다.
> 
- **Kurento특징**
    1. **모듈식 파이프라인**
        
        Kurento는 **WebRTC** 및 **RTP** 발신자 및 수신자, 오디오/비디오 **믹서** , **미디어 녹음** 등과 같은 빌딩 블록 제공 
        
        미디어가 이미 흐르는 경우에도 언제든지 삽입, 활성화 또는 비활성화 하여 **구성** 하기 쉽다.
        
        **또한 Kurento를 확장** 하고 자신만의 요소를 작성 하는 것도 매우 쉽습니다. 그러면 이미 존재하는 요소와 통합될 수 있습니다!
        
        애플리케이션 개발자는 Kurento를 사용하여 원하는 미디어 요소로 소위 *미디어 파이프라인* 을 제어 하여 필요에 맞게 완전히 맞춤화된 아키텍처를 효과적으로 형성합니다. **그룹 통신** , 미디어 형식 **트랜스코딩** 및 시청각 흐름 **라우팅** 을 위해 여러 내장 모듈이 제공됩니다 .
        
        Kurento가 제공하는 유연한 모듈식 접근 방식을 고려할 때 *SFU* ( **Selective Forwarding Unit** ) 및 *MCU* ( **Multipoint Conferencing Unit** ) 애플리케이션 아키텍처를 모두 달성할 수 있습니다.
        
    2. **내장 모듈**
        
        Kurento는 API의 일부로 미디어 요소의 풍부한 도구 상자를 노출합니다.
        
        ![https://doc-kurento.readthedocs.io/en/latest/_images/kurento-toolbox-basic.png](https://doc-kurento.readthedocs.io/en/latest/_images/kurento-toolbox-basic.png)
        
        *Kurento에서 기본 제공되는 일부 미디어 요소*
        
        예를 들어:
        
        - WebRtcEndpoint 는 [WebRTC](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-WebRTC) 미디어 스트림 을 보내고 받을 수 **있습니다 .**
        - **PlayerEndpoint 는 RTSP** , **HTTP** 또는 로컬 소스 에서 미디어를 사용하는 데 사용할 수 있습니다 .
        - **RecorderEndpoint** 는 미디어 스트림을 로컬 또는 원격 파일 시스템에 저장할 수 있습니다.
        - **FaceOverlayFilter** 는 비디오 스트림에서 사람의 얼굴을 감지하여 그 위에 오버레이 이미지를 추가하는 간단한 Computer Vision 예제입니다.
        
        kurento로 구축된 애플리케이션에서 사용되는 이러한 모든 요소의 실제 예를 보려면 [자습서](https://doc-kurento.readthedocs.io/en/latest/user/tutorials.html) 로 바로 이동 하십시오.
        
        자세히 알아보려면 [Kurento 모듈](https://doc-kurento.readthedocs.io/en/latest/features/kurento_modules.html) 에 대한 섹션을 읽으십시오 . 또한, Kurento에는 [자신만의 모듈을 작성할](https://doc-kurento.readthedocs.io/en/latest/user/writing_modules.html) 수 있는 플러그인 API가 있다는 것을 기억하십시오 !
        
    3. **JSON-RPC 프로토콜**
        
        KMS는 WebSocket 연결을 통해 직접 액세스할 수 있는 [Kurento Protocol](https://doc-kurento.readthedocs.io/en/latest/features/kurento_protocol.html) 이라는 JSON-RPC 프로토콜을 통해 모든 API 기능을 노출합니다 . 편의를 위해 Kurento는 Java 및 JavaScript SDK: [클라이언트 API 참조](https://doc-kurento.readthedocs.io/en/latest/features/kurento_client.html) 도 제공합니다 . 그러나 프로토콜에 대해 직접 코드를 작성하기 만 하면 **모든 프로그래밍 언어** 를 사용할 수 있습니다 .
        
        아래 그림은 세 가지 시나리오에서 Kurento를 사용하는 방법을 보여줍니다.
        
        - WebRTC 브라우저에서 직접 Kurento JavaScript SDK 사용(프로덕션 서비스가 아닌 빠른 테스트 및 개발에만 권장됨).
        - 독립 실행형 Java EE 애플리케이션 서버에서 Kurento Java SDK 사용. 웹 브라우저는 HTML 및 [WebRTC](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-WebRTC) 시그널링과 같은 이 애플리케이션의 클라이언트인 반면 애플리케이션 자체는 KMS의 클라이언트입니다(KMS를 제어하기 위해 Kurento 프로토콜 사용).
        - Node.js 애플리케이션 서버에서 Kurento JavaScript SDK 사용. 다시 말하지만, 웹 브라우저는 이 애플리케이션의 클라이언트이고 애플리케이션은 KMS의 클라이언트입니다.
        
        ![https://doc-kurento.readthedocs.io/en/latest/_images/kurento-clients-connection.png](https://doc-kurento.readthedocs.io/en/latest/_images/kurento-clients-connection.png)
        
        *Kurento Media Server에 Kurento Java 및 JavaScript SDK 연결*
        
        지원되는 SDK 기술에 대한 전체 예제는 [자습서](https://doc-kurento.readthedocs.io/en/latest/user/tutorials.html) 에 설명되어 있습니다.
        
- **Kurento를 사용할 수 있는 3가지 방법**
    1. 웹소켓 브라우저로부터 직접적으로 Kurento JavaScript SDK 사용하기(빠르게 테스트할때 추천)
    2. JavaEE 서버에서 Kurento Java SDK를 사용하기(웹브라우저는 HTML, WebRTC시그널링과 같은 작업을 위한 애플리케이션의 클라이언트)
    3. Node.js에 Kurento JavaScript SDK를 사용하기
- **Media Server를 왜사용하는가?**
    
    [WebRTC](https://webrtc.org/) 는 웹 브라우저와 모바일 애플리케이션에 피어 투 피어 연결을 통해 실시간 통신(RTC) 기능을 제공하는 일련의 프로토콜 및 API입니다. 중간 도우미나 서비스 없이 브라우저를 연결할 수 있도록 고안되었지만 실제로 이 P2P 모델은 더 복잡한 응용 프로그램을 만들려고 할 때 부족합니다. 이러한 이유로 대부분의 경우 중앙 미디어 서버가 필요합니다.
    
    ![https://doc-kurento.readthedocs.io/en/latest/_images/media-server-intro.png](https://doc-kurento.readthedocs.io/en/latest/_images/media-server-intro.png)
    
    *P2P WebRTC 접근과 미디어 서버를 통한 WebRTC 비교*
    
    개념적으로 WebRTC 미디어 서버는 소스에서 대상으로 이동할 때 미디어 트래픽이 통과하는 멀티미디어 미들웨어입니다.
    
- **Media Server는 어떤 기능을 제공하는가?**
    
    미디어 서버는 들어오는 미디어 스트림을 처리할 수 있으며 다음과 같은 다양한 결과를 제공합니다.
    
    - 그룹 통신(Group Communications): 한 피어가 생성하는 미디어 스트림을 여러 수신기에 배포하는 것, 즉 다중 회의 장치("MCU") 역할을 합니다.
    - 혼합(Mixing): 여러 수신 스트림을 하나의 단일 복합 스트림으로 변환합니다.
    - 트랜스코딩(Transcoding): 호환되지 않는 클라이언트 간에 코덱 및 형식을 즉시 적용합니다.
    - 녹음(Recording): 피어 간에 교환되는 미디어를 지속적으로 저장합니다.
    
    ![https://doc-kurento.readthedocs.io/en/latest/_images/media-server-capabilities.png](https://doc-kurento.readthedocs.io/en/latest/_images/media-server-capabilities.png)
    
    *일반적인 WebRTC 미디어 서버 기능*
    
- **KMS(Kurento Media Service)가 제공하는 기능**
    
    **KMS( Kurento Media Server** )는 *WebRTC 미디어 서버* 모델에서 사용하여 미디어 전송, 처리, 녹음 및 재생을 허용할 수 있습니다. KMS는 환상적인 [GStreamer](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-GStreamer) 멀티미디어 라이브러리를 기반으로 구축되었으며 다음과 같은 기능을 제공합니다.
    
    - [HTTP](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-HTTP) , [RTP](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-RTP) 및 [WebRTC](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-WebRTC) 를 포함한 네트워크 스트리밍 프로토콜 .
    - 미디어 믹싱 및 미디어 라우팅/디스패칭을 지원하는 그룹 통신( MCU *및 SFU 기능 모두 ).*
    - **Computer Vision** 및 **Augmented Reality** 알고리즘 을 구현하는 필터에 대한 일반 지원 .
    - [WebM](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-WebM) 및 [MP4](https://doc-kurento.readthedocs.io/en/latest/glossary.html#term-MP4) *에 대한 쓰기 작업과 GStreamer* 에서 지원하는 모든 형식의 재생 을 지원하는 미디어 저장소입니다 .
    - VP8, H.264, H.263, AMR, OPUS, Speex, G.711 등을 포함하여 GStreamer에서 지원하는 모든 코덱 간의 자동 미디어 트랜스코딩.
    
    ![https://doc-kurento.readthedocs.io/en/latest/_images/kurento-media-server-intro.png](https://doc-kurento.readthedocs.io/en/latest/_images/kurento-media-server-intro.png)
    
    *Kurento 미디어 서버 기능*
    
- **Kurento디자인 원리**
    
    Kurento는 다음과 같은 주요 원칙에 따라 설계되었습니다.
    
    > 미디어 및 애플리케이션 서비스 배포Kurento Media Server 및 애플리케이션은 다른 시스템에 배포, 에스컬레이션 또는 배포될 수 있습니다.단일 애플리케이션은 둘 이상의 Kurento Media Server의 서비스를 호출할 수 있습니다. 그 반대도 적용됩니다. 즉, Kurento Media Server는 둘 이상의 애플리케이션 요청에 참석할 수 있습니다.클라우드에 적합Kurento는 클라우드 환경에 통합되어 PaaS(Platform as a Service) 구성 요소로 작동하는 데 적합합니다.미디어 파이프라인미디어 파이프라인 을 통해 미디어 요소 를 연결 하는 것은 멀티미디어 처리의 복잡성에 도전하는 직관적인 접근 방식입니다.응용 프로그램 개발개발자는 내부 Kurento Media Server 복잡성을 알 필요가 없습니다. 모든 애플리케이션은 클라이언트에서 서버에 이르기까지 개발자가 좋아하는 모든 기술이나 프레임워크에 배포할 수 있습니다. 브라우저에서 클라우드 서비스까지.종단 간 통신 기능Kurento는 종단 간 통신 기능을 제공하므로 개발자는 클라이언트 장치에서 미디어 전송, 인코딩/디코딩 및 렌더링의 복잡성을 처리할 필요가 없습니다.완전히 처리 가능한 미디어 스트림Kurento는 대화형 대인 통신(예: Skype와 같은 대화식 통화 푸시/수신 기능)뿐만 아니라 인간 대 기계(예: 실시간 스트리밍을 통한 주문형 비디오) 및 기계 대 기계(예: 원격 비디오 녹화)를 가능하게 합니다. , 다감각 데이터 교환) 통신.미디어의 모듈식 처리미디어 요소 와 파이프라인 을 통해 모듈화를 달성 하면 "그래프 지향" 언어를 통해 애플리케이션의 미디어 처리 기능을 정의할 수 있습니다. 여기서 애플리케이션 개발자는 적절한 기능을 연결하여 원하는 로직을 생성할 수 있습니다.감사 가능한 처리Kurento는 QoS 모니터링, 청구 및 감사를 위한 풍부하고 상세한 정보를 생성할 수 있습니다.원활한 IMS 통합Kurento는 Telephony Carriers의 IMS 인프라 로의 원활한 통합을 지원하도록 설계되었습니다 .투명 미디어 적응 계층Kurento는 화면 크기, 전력 소비, 전송 속도 등의 요구 사항이 서로 다른 여러 장치 간의 컨버전스를 가능하게 하는 투명한 미디어 적응 계층을 제공합니다.
    > 

### Docker로 실행시키기

- 참조링크
    - [https://doc-kurento.readthedocs.io/en/stable/tutorials/java/tutorial-helloworld.html](https://doc-kurento.readthedocs.io/en/stable/tutorials/java/tutorial-helloworld.html)
    - [https://gh402.tistory.com/44?category=935378](https://gh402.tistory.com/44?category=935378)
1. 쿠렌토 이미지 받아오기

```jsx
sudo docker pull kurento/kurento-media-server:latest
```

1. 이미지 실행시키기 (+포트설정)

```jsx
sudo docker run -d --name kms --network host kurento/kurento-media-server:latest

sudo docker run --rm -p 8888:8888/tcp -p 5000-5050:5000-5050/udp -e KMS_MIN_PORT=5000 -e KMS_MAX_PORT=5050 kurento/kurento-media-server:latest

sudo docker run -d -p 8888:8888/tcp -p 5000-5050:5000-5050/udp -e KMS_MIN_PORT=5000 -e KMS_MAX_PORT=5050 kurento/kurento-media-server:latest

-d : 백그라운드에서 실행해라
--name : 실행시키는 이미지에 네임태크 부여
--rm : 컨테이너를 일회성으로 실행할 때 주로 사용. 컨테이너가 종료될 때 컨테이너와 관련된 리소스(파일 시스템, 볼륨)까지 깨끗이 제거
```

1. git에서 kurento tutorial clone하기

```jsx
git clone https://github.com/Kurento/kurento-tutorial-java.git
```

1. tutorial코드 실행

```jsx
cd kurento-tutorial-java/kurento-hello-world
git checkout 6.16.0
mvn -U clean spring-boot:run \
    -Dspring-boot.run.jvmArguments="-Dkms.url=ws://{KMS_HOST}:8888/kurento"
```

1. [https://localhost:8443/](https://localhost:8443/) 로 접속

![Untitled](KURENTO%20e150a267cf5a4930a2d4f4c9faa98517/Untitled.png)

---

### Kurento의 STUN/TURN서버 설정

1. 컨테이너 실행 확인 

```jsx
sudo docker ps -a
```

![Untitled](KURENTO%20e150a267cf5a4930a2d4f4c9faa98517/Untitled%201.png)

1. Kurento 컨테이너 터미널에 접속

```jsx
sudo docker exec -it (컨테이너의 해쉬값) /bin/bash
sudo docker exec -it 45f15b2dbb7b /bin/bash
```

![Untitled](KURENTO%20e150a267cf5a4930a2d4f4c9faa98517/Untitled%202.png)

1. Kurento WebRtcEndpoint.ini 수정

```jsx
vi /etc/kurento/modules/kurento/WebRtcEndpoint.conf.ini
```

WebRtcEndpoint.conf.ini파일에서 

```jsx
stunServerAddress=<EC2의 퍼블릭 IPv4 주소>
stunServerPort=3478
turnURL=myuer:mypassword@<EC2의 퍼블릭 IPv4 주소>?transport=udp
```

로 수정

<vi가 설치되지 않았을 때>

```jsx
apt-get update
apt-get install vim
```

### STUN/TURN 서버설치(외부와 통신하기위해 필요함)

> 오픈소스인 Coturn을 사용했다.
> 
- 참조링크
    
    [https://doc-kurento.readthedocs.io/en/latest/user/installation.html#installation-stun-turn](https://doc-kurento.readthedocs.io/en/latest/user/installation.html#installation-stun-turn)
    
    [https://brunch.co.kr/@linecard/156](https://brunch.co.kr/@linecard/156)
    
1. 인바운드 포트허용

```jsx
//tcp경우
sudo iptables -I INPUT 1 -p tcp --dport 3478 -j ACCEPT

//udp경우
sudo iptables -I INPUT 1 -p udp --dport 3478 -j ACCEPT

for i in {시작포트..끝포트}; do nc -kl $i &; done
```

1. Coturn 설치 ([https://meetrix.io/blog/webrtc/coturn/installation.html](https://meetrix.io/blog/webrtc/coturn/installation.html))

```jsx
//직접설치??
sudo apt-get update && sudo apt-get install --no-install-recommends --yes coturn

//도커이미지(명령어실행시 이미지가 없을 경우 이미지 자동 다운로드후 컨테이너 실행)
docker run -d --network=host instrumentisto/coturn
```

1. Coturn설정

```jsx
sudo vim /etc/default/coturn 파일 아래와 같이 수정

TURNSERVER_ENABLED=1

/etc/turnserver.conf 파일 수정
참조링크 : https://buttercoco.tistory.com/25
# turnserver의 포트입니다.
listening-port=3478
# tls 포트입니다.
tls-listening-port=5349
# 외부IP를 넣어줍니다.(공유기 사용시 WAN상의 외부IP를 넣어줍니다.)
external-ip=123.123.126.123
# 로그를 뽑을 수 있음
verbose
# 이것도 주석해제
fingerprint
# 인증방식 주석해제
lt-cred-mech
# turnserver 도메인 네임입니다.
server-name=test.com
# 릴름은 원하는 네임명으로 해줍니다.
realm=testname

```

1. Coturn 재가동

```jsx
sudo service coturn restart
```

1. 참조링크에서 STUN/TURN서버 설정(명세서와 다른점이 있음 / 4번 이후 별다른 수정없이 진행했다.)

### Web Socket

- 참조링크
    
    [https://supawer0728.github.io/2018/03/30/spring-websocket/](https://supawer0728.github.io/2018/03/30/spring-websocket/)
    
    [https://sup2is.github.io/2019/06/05/websocket-1.html](https://sup2is.github.io/2019/06/05/websocket-1.html)
    

Web Browser에서 Request를 보내면 Server는 Response를 준다. HTTP 통신의 기본적인 동작 방식이다. 하지만 Server에서 Client로 특정 동작을 알려야 하는 상황도 있다. 예를 들어 Browser로 Facebook에 접속해 있다가 누군가 친구가 글을 등록하는 경우, 혹은 Web Browser로 메신저를 구현하는 경우다. WebSocket이 있기 전에는 이를 Polling이나 Long polling 등의 방식으로 해결했었다. 하지만 WebSocket의 등장으로 Server-Client 간의 실시간 통신이 가능하게 되면서, 앞으로 Long polling은 역사의 뒤안길로 사라질 것 같다.

> **WebSocket**이란 HTTP 환경에서 **전이중 통신(full duplex, 2-way communication)**을 지원하기 위한 프로토콜로, [RFC 6455](https://tools.ietf.org/html/rfc6455)에 정의되어 있다. HTTP 프로토콜에서 Handshaking을 완료한 후, HTTP로 동작을 하지만, HTTP와는 다른 방식으로 통신을 한다.
> 

---

- **WebSocket이 있기 전에** → Polling이나 Long polling 등의 방식으로 해결, but 주기적으로 통신을 확인해야하기 때문에 리소스 낭비가 크다.
- **WebSocket의 등장**으로 **Server-Client 간의 실시간 통신이 가능**하게 됨
- [Spring Reference](https://docs.spring.io/spring/docs/5.0.4.RELEASE/spring-framework-reference/web.html#websocket-intro-when-to-use)을 참조하면, `자주 + 많은 양의 + 지연이 짧아야 하는 통신`을 할 수록 WebSocket이 적합하다고 설명하고 있다.(ex. 게임, 채팅)

---

### **WebSocket Sevrer를 운용할 때의 유의사항**

- HTTP에서 동작하나, 그 방식이 HTTP와는 많이 상이하다.
    - REST한 방식의 HTTP 통신에서는 많은 URI를 통해 application이 설계된다.
    - WebSocket은 하나의 URL을 통해 Connection이 맺어지고, 후에는 해당 Connection으로만 통신한다.
- Handshake가 완료되고 Connection을 유지한다.
    - 전통적인 HTTP 통신은 요청-응답이 완료되면 Connection을 close한다. 때문에 이론상 하나의 Server가 Port 수의 한계(`n<65535`)를 넘는 client의 요청을 처리할 수 있다.
    - WebSocket은 Connection을 유지하고 있으므로, 가용 Port 수만큼의 Client와 통신할 수 있다.

Spring의 지원을 받아 Web Application Server에서 HTTP를 지원하면서 WebSocket도 지원할 수 있다. 하지만 HTTP와 WebSocket의 개념이 많이 상이하다 보니, WebSocket을 사용해야 한다면 전용 Server를 구축하는 편이 운영하기 쉬울 것으로 판단된다.

### ICE(Interactive Connectivity Establishment)

- 참조링크
    
    [https://brunch.co.kr/@linecard/156](https://brunch.co.kr/@linecard/156)
    

> 두 단말이 서로 통신할 수 있는 최적의 경로를 찾을 수 있도록 도와주는 프레임워크
> 

> Candidate : IP주소와 포트넘버의 조합으로 표시된 주소
> 
- ICE Candidate Gathering : 통신가능한 모든 주소를 획득하는 과정
    
    TURN서버에서 Relayed Candidate와 Server Reflexive Candidate를 응답
    
    STUN서버에서 Server Reflexive Candidate를 응답
    
    사설망은 총 3개의 주소를 획득
    
    - Local Address : 자신의 사설 IP주소와 포트넘버
    - Server Reflexive Address : 자신의 공인 IP주소와 포트넘버
    - Relayed Address : TURN 서버의 IP 주소와 포트넘버

### 시그널링서버

- https사용을 위해
    
    준비물 : .pem 키
    
    1. pem 키를 p12로
    
    ```java
    터미널에 다음명령어를 이용해 pem키를 p12로 바꾼다.
    keytool -genkeypair -alias ssafy -keyalg RSA -keysize 2048 -storetype PKCS12 -keystore ssafy.p12 -validity 3650
    ```
    
    1. 프로젝트에 넣는다.(src\main\resources\keystore)
    2. application.properties를 수정한다.
    
    ```java
    server.port=8443
    server.http.port=8080
    server.ssl.enabled=true
    server.ssl.key-store-type=PKCS12
    server.ssl.key-store=classpath:keystore/ssafy.p12
    server.ssl.key-store-password=ssafyssafy
    server.ssl.key-alias=ssafy
    trust.store=classpath:keystore/ssafy.p12
    trust.store.password=ssafyssafy
    ```
    

### Kurento Tutorial분석

- **GroupCall**
    - GroupCallApp.java
        
        ```java
        import org.kurento.client.KurentoClient;
        import org.springframework.boot.SpringApplication;
        import org.springframework.boot.autoconfigure.SpringBootApplication;
        import org.springframework.context.annotation.Bean;
        import org.springframework.web.socket.config.annotation.EnableWebSocket;
        import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
        import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;
        import org.springframework.web.socket.server.standard.ServletServerContainerFactoryBean;
        
        /**
         *
         * @author Ivan Gracia (izanmail@gmail.com)
         * @since 4.3.1
         */
        @SpringBootApplication
        @EnableWebSocket
        public class GroupCallApp implements WebSocketConfigurer {
          //필요한 class를 spring bean에 등록한다.(시작)
          @Bean
          public UserRegistry registry() {
            return new UserRegistry();
          }
        
          @Bean
          public RoomManager roomManager() {
            return new RoomManager();
          }
        
          @Bean
          public CallHandler groupCallHandler() {
            return new CallHandler();
          }
        
          @Bean
          public KurentoClient kurentoClient() {
            return KurentoClient.create();
          }
        
          @Bean
          public ServletServerContainerFactoryBean createServletServerContainerFactoryBean() {
            ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
            container.setMaxTextMessageBufferSize(32768);
            return container;
          }
          //필요한 class를 spring bean에 등록한다.(끝)
          public static void main(String[] args) throws Exception {
            SpringApplication.run(GroupCallApp.class, args);
          }
        
          @Override
          public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
            //연결할 웹소켓의 url과 핸들러를 등록한다.
            registry.addHandler(groupCallHandler(), "/groupcall");
          }
        }
        ```
        
    - CallHandler.java
        
        ```java
        import java.io.IOException;
        
        import org.kurento.client.IceCandidate;
        import org.slf4j.Logger;
        import org.slf4j.LoggerFactory;
        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.web.socket.CloseStatus;
        import org.springframework.web.socket.TextMessage;
        import org.springframework.web.socket.WebSocketSession;
        import org.springframework.web.socket.handler.TextWebSocketHandler;
        
        import com.google.gson.Gson;
        import com.google.gson.GsonBuilder;
        import com.google.gson.JsonObject;
        
        /**
         * 
         * @author Ivan Gracia (izanmail@gmail.com)
         * @since 4.3.1
         */
        public class CallHandler extends TextWebSocketHandler {
        
          private static final Logger log = LoggerFactory.getLogger(CallHandler.class);
        
          private static final Gson gson = new GsonBuilder().create();
        
          @Autowired
          private RoomManager roomManager;
        
          @Autowired
          private UserRegistry registry;//현재 연결된 user의 session을 user의 name을 key로하는 map을 가지고 있다.
        
          //client 에서 받아온 메세지를 다루는 메소드 ->TextWebSocketHandler를 상속받았기 때문에 handleTextMessage를 구현
          //TextWebSocketHandler이외에 BinaryWebSocketHandler도 지원한다.
          @Override
          public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
            final JsonObject jsonMessage = gson.fromJson(message.getPayload(), JsonObject.class);//message에 담긴 payload를 jsonObject형태로 저장한다.
        
            final UserSession user = registry.getBySession(session);//session에 연결된 user를 registry에서 꺼내온다.
        
            if (user != null) {//session이 registry에 존재한다면
              log.debug("Incoming message from user '{}': {}", user.getName(), jsonMessage);
            } else {//session이 registry에 존재하지 않는다면
              log.debug("Incoming message from new user: {}", jsonMessage);
            }
        
            //message로 받아온 동작에 따라 분기
            switch (jsonMessage.get("id").getAsString()) {
              case "joinRoom"://채팅방에 입장하는 메세지
                joinRoom(jsonMessage, session);
                break;
              case "receiveVideoFrom"://비디오영상을 받는 메세지??
                final String senderName = jsonMessage.get("sender").getAsString();//메세지를 보낸사람
                final UserSession sender = registry.getByName(senderName);//보낸사람의 session을 가져온다.
                final String sdpOffer = jsonMessage.get("sdpOffer").getAsString();//sdpOffer : 어떤 방식으로 연결될지 공유하기 위해 필요한 것
                user.receiveVideoFrom(sender, sdpOffer);
                break;
              case "leaveRoom"://채팅방 퇴장 메세지
                leaveRoom(user);
                break;
              case "onIceCandidate"://????
                JsonObject candidate = jsonMessage.get("candidate").getAsJsonObject();
        
                if (user != null) {//유저 세션이 존재한다면
                  IceCandidate cand = new IceCandidate(candidate.get("candidate").getAsString(),
                      candidate.get("sdpMid").getAsString(), candidate.get("sdpMLineIndex").getAsInt());
                  user.addCandidate(cand, jsonMessage.get("name").getAsString());//유저세션에 접속가능한 주소 추가
                }
                break;
              default:
                break;
            }
          }
          //웹소켓 클라이언트와 연결이 끊겼을때 호출이된다.
          @Override
          public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
            UserSession user = registry.removeBySession(session);//끊으려는 session을 registry에서 지운 후 userSession을 가져온다
            roomManager.getRoom(user.getRoomName()).leave(user);// 유저를 방에서 내보낸다.
          }
        
          private void joinRoom(JsonObject params, WebSocketSession session) throws IOException {
            //message에 담겨있는 userName과 roomName을 받아온다.
            final String roomName = params.get("room").getAsString();
            final String name = params.get("name").getAsString();
            log.info("PARTICIPANT {}: trying to join room {}", name, roomName);
        
            Room room = roomManager.getRoom(roomName);//roomName으로 생성되어있는 room을 가져온다.
            final UserSession user = room.join(name, session);//name과 session을 room의 pipeline과 연결시켜 UserSession을 생성한다.
            registry.register(user);//생성된 UserSession을 등록한다.
          }
        
          private void leaveRoom(UserSession user) throws IOException {
            final Room room = roomManager.getRoom(user.getRoomName());//유저가 접속해있는 방을 가져온다.
            room.leave(user);//유저를 방에서 내보낸다.
            if (room.getParticipants().isEmpty()) {//방에 남아있는 참가자가 없다면
              roomManager.removeRoom(room);//방을 삭제한다.
            }
          }
        }
        ```
        
    - Room.java
        
        ```java
        import java.io.Closeable;
        import java.io.IOException;
        import java.util.ArrayList;
        import java.util.Collection;
        import java.util.List;
        import java.util.concurrent.ConcurrentHashMap;
        import java.util.concurrent.ConcurrentMap;
        
        import javax.annotation.PreDestroy;
        
        import org.kurento.client.Continuation;
        import org.kurento.client.MediaPipeline;
        import org.slf4j.Logger;
        import org.slf4j.LoggerFactory;
        import org.springframework.web.socket.WebSocketSession;
        
        import com.google.gson.JsonArray;
        import com.google.gson.JsonElement;
        import com.google.gson.JsonObject;
        import com.google.gson.JsonPrimitive;
        
        /**
         * @author Ivan Gracia (izanmail@gmail.com)
         * @since 4.3.1
         */
        public class Room implements Closeable {
          private final Logger log = LoggerFactory.getLogger(Room.class);
        
          private final ConcurrentMap<String, UserSession> participants = new ConcurrentHashMap<>();
          private final MediaPipeline pipeline;
          private final String name;
        
          public String getName() {
            return name;
          }
        
          public Room(String roomName, MediaPipeline pipeline) {
            this.name = roomName;
            this.pipeline = pipeline;
            log.info("ROOM {} has been created", roomName);
          }
        
          @PreDestroy
          private void shutdown() {
            this.close();
          }
        
          public UserSession join(String userName, WebSocketSession session) throws IOException {
            log.info("ROOM {}: adding participant {}", this.name, userName);
            final UserSession participant = new UserSession(userName, this.name, session, this.pipeline);
            joinRoom(participant);
            participants.put(participant.getName(), participant);
            sendParticipantNames(participant);
            return participant;
          }
        
          public void leave(UserSession user) throws IOException {
            log.debug("PARTICIPANT {}: Leaving room {}", user.getName(), this.name);
            this.removeParticipant(user.getName());//유저를 방에서 내보낸다.
            user.close();
          }
        
          private Collection<String> joinRoom(UserSession newParticipant) throws IOException {
            final JsonObject newParticipantMsg = new JsonObject();
            newParticipantMsg.addProperty("id", "newParticipantArrived");
            newParticipantMsg.addProperty("name", newParticipant.getName());
        
            final List<String> participantsList = new ArrayList<>(participants.values().size());
            log.debug("ROOM {}: notifying other participants of new participant {}", name,
                newParticipant.getName());
        
            for (final UserSession participant : participants.values()) {
              try {
                participant.sendMessage(newParticipantMsg);
              } catch (final IOException e) {
                log.debug("ROOM {}: participant {} could not be notified", name, participant.getName(), e);
              }
              participantsList.add(participant.getName());
            }
        
            return participantsList;
          }
        
          private void removeParticipant(String name) throws IOException {
            participants.remove(name);//참가자목록에서 유저를 삭제한다.
        
            log.debug("ROOM {}: notifying all users that {} is leaving the room", this.name, name);
        
            final List<String> unnotifiedParticipants = new ArrayList<>();
            final JsonObject participantLeftJson = new JsonObject();
            participantLeftJson.addProperty("id", "participantLeft");
            participantLeftJson.addProperty("name", name);
            for (final UserSession participant : participants.values()) {
              try {
                participant.cancelVideoFrom(name);//나가려는 유저와 비디오연결을 끊는다?
                participant.sendMessage(participantLeftJson);//
              } catch (final IOException e) {
                unnotifiedParticipants.add(participant.getName());
              }
            }
        
            if (!unnotifiedParticipants.isEmpty()) {
              log.debug("ROOM {}: The users {} could not be notified that {} left the room", this.name,
                  unnotifiedParticipants, name);
            }
        
          }
        
          public void sendParticipantNames(UserSession user) throws IOException {
        
            final JsonArray participantsArray = new JsonArray();
            for (final UserSession participant : this.getParticipants()) {
              if (!participant.equals(user)) {
                final JsonElement participantName = new JsonPrimitive(participant.getName());
                participantsArray.add(participantName);
              }
            }
        
            final JsonObject existingParticipantsMsg = new JsonObject();
            existingParticipantsMsg.addProperty("id", "existingParticipants");
            existingParticipantsMsg.add("data", participantsArray);
            log.debug("PARTICIPANT {}: sending a list of {} participants", user.getName(),
                participantsArray.size());
            user.sendMessage(existingParticipantsMsg);
          }
        
          public Collection<UserSession> getParticipants() {
            return participants.values();
          }
        
          public UserSession getParticipant(String name) {
            return participants.get(name);
          }
        
          @Override
          public void close() {
            for (final UserSession user : participants.values()) {
              try {
                user.close();
              } catch (IOException e) {
                log.debug("ROOM {}: Could not invoke close on participant {}", this.name, user.getName(),
                    e);
              }
            }
        
            participants.clear();
        
            pipeline.release(new Continuation<Void>() {
        
              @Override
              public void onSuccess(Void result) throws Exception {
                log.trace("ROOM {}: Released Pipeline", Room.this.name);
              }
        
              @Override
              public void onError(Throwable cause) throws Exception {
                log.warn("PARTICIPANT {}: Could not release Pipeline", Room.this.name);
              }
            });
        
            log.debug("Room {} closed", this.name);
          }
        
        }
        ```
        
    - RoomManager.java
        
        ```java
        import java.util.concurrent.ConcurrentHashMap;
        import java.util.concurrent.ConcurrentMap;
        
        import org.kurento.client.KurentoClient;
        import org.slf4j.Logger;
        import org.slf4j.LoggerFactory;
        import org.springframework.beans.factory.annotation.Autowired;
        
        /**
         * @author Ivan Gracia (izanmail@gmail.com)
         * @since 4.3.1
         */
        public class RoomManager {
        
          private final Logger log = LoggerFactory.getLogger(RoomManager.class);
        
          @Autowired
          private KurentoClient kurento;
        
          private final ConcurrentMap<String, Room> rooms = new ConcurrentHashMap<>();
        
          /**
           * Looks for a room in the active room list.
           *
           * @param roomName
           *          the name of the room
           * @return the room if it was already created, or a new one if it is the first time this room is
           *         accessed
           */
          public Room getRoom(String roomName) {
            log.debug("Searching for room {}", roomName);
            Room room = rooms.get(roomName);
        
            if (room == null) {
              log.debug("Room {} not existent. Will create now!", roomName);
              room = new Room(roomName, kurento.createMediaPipeline());
              rooms.put(roomName, room);
            }
            log.debug("Room {} found!", roomName);
            return room;
          }
        
          /**
           * Removes a room from the list of available rooms.
           *
           * @param room
           *          the room to be removed
           */
          public void removeRoom(Room room) {
            this.rooms.remove(room.getName());
            room.close();
            log.info("Room {} removed and closed", room.getName());
          }
        
        }
        ```
        
    - UserRegistry.java
        
        현재 저장된 유저의 해쉬맵(name을 key로 하는)을 가지고있다.
        
        ```java
        import java.util.concurrent.ConcurrentHashMap;
        
        import org.springframework.web.socket.WebSocketSession;
        
        /**
         * Map of users registered in the system. This class has a concurrent hash map to store users, using
         * its name as key in the map.
         * 
         * @author Boni Garcia (bgarcia@gsyc.es)
         * @author Micael Gallego (micael.gallego@gmail.com)
         * @authos Ivan Gracia (izanmail@gmail.com)
         * @since 4.3.1
         */
        public class UserRegistry {
        
          private final ConcurrentHashMap<String, UserSession> usersByName = new ConcurrentHashMap<>();
          private final ConcurrentHashMap<String, UserSession> usersBySessionId = new ConcurrentHashMap<>();
        
          public void register(UserSession user) {
            usersByName.put(user.getName(), user);
            usersBySessionId.put(user.getSession().getId(), user);
          }
        
          public UserSession getByName(String name) {
            return usersByName.get(name);
          }
        
          public UserSession getBySession(WebSocketSession session) {
            return usersBySessionId.get(session.getId());
          }
        
          public boolean exists(String name) {
            return usersByName.keySet().contains(name);
          }
        
          public UserSession removeBySession(WebSocketSession session) {
            final UserSession user = getBySession(session);
            usersByName.remove(user.getName());
            usersBySessionId.remove(session.getId());
            return user;
          }
        
        }
        ```
        
    - UserSession
        
        ```java
        import java.io.Closeable;
        import java.io.IOException;
        import java.util.concurrent.ConcurrentHashMap;
        import java.util.concurrent.ConcurrentMap;
        
        import org.kurento.client.Continuation;
        import org.kurento.client.EventListener;
        import org.kurento.client.IceCandidate;
        import org.kurento.client.IceCandidateFoundEvent;
        import org.kurento.client.MediaPipeline;
        import org.kurento.client.WebRtcEndpoint;
        import org.kurento.jsonrpc.JsonUtils;
        import org.slf4j.Logger;
        import org.slf4j.LoggerFactory;
        import org.springframework.web.socket.TextMessage;
        import org.springframework.web.socket.WebSocketSession;
        
        import com.google.gson.JsonObject;
        
        /**
         *
         * @author Ivan Gracia (izanmail@gmail.com)
         * @since 4.3.1
         */
        public class UserSession implements Closeable {
        
          private static final Logger log = LoggerFactory.getLogger(UserSession.class);
        
          private final String name;//유저의 이름
          private final WebSocketSession session;//sessionId
        
          private final MediaPipeline pipeline;//연결된 채팅방의 pipeLine
        
          private final String roomName;//연결된 채팅방의 이름
          private final WebRtcEndpoint outgoingMedia;//파이프라인에 연결된 endPoint???
          private final ConcurrentMap<String, WebRtcEndpoint> incomingMedia = new ConcurrentHashMap<>();
        
          public UserSession(final String name, String roomName, final WebSocketSession session,
              MediaPipeline pipeline) {
        
            this.pipeline = pipeline;
            this.name = name;
            this.session = session;
            this.roomName = roomName;
            this.outgoingMedia = new WebRtcEndpoint.Builder(pipeline).build();
        
            this.outgoingMedia.addIceCandidateFoundListener(new EventListener<IceCandidateFoundEvent>() {
        
              @Override
              public void onEvent(IceCandidateFoundEvent event) {
                JsonObject response = new JsonObject();
                response.addProperty("id", "iceCandidate");
                response.addProperty("name", name);
                response.add("candidate", JsonUtils.toJsonObject(event.getCandidate()));
                try {
                  synchronized (session) {
                    session.sendMessage(new TextMessage(response.toString()));
                  }
                } catch (IOException e) {
                  log.debug(e.getMessage());
                }
              }
            });
          }
        
          public WebRtcEndpoint getOutgoingWebRtcPeer() {
            return outgoingMedia;
          }
        
          public String getName() {
            return name;
          }
        
          public WebSocketSession getSession() {
            return session;
          }
        
          /**
           * The room to which the user is currently attending.
           *
           * @return The room
           */
          public String getRoomName() {
            return this.roomName;
          }
        
          public void receiveVideoFrom(UserSession sender, String sdpOffer) throws IOException {
            log.info("USER {}: connecting with {} in room {}", this.name, sender.getName(), this.roomName);
        
            log.trace("USER {}: SdpOffer for {} is {}", this.name, sender.getName(), sdpOffer);
        
            final String ipSdpAnswer = this.getEndpointForUser(sender).processOffer(sdpOffer);//
            final JsonObject scParams = new JsonObject();
            scParams.addProperty("id", "receiveVideoAnswer");
            scParams.addProperty("name", sender.getName());
            scParams.addProperty("sdpAnswer", ipSdpAnswer);
        
            log.trace("USER {}: SdpAnswer for {} is {}", this.name, sender.getName(), ipSdpAnswer);
            this.sendMessage(scParams);
            log.debug("gather candidates");
            this.getEndpointForUser(sender).gatherCandidates();
          }
        
          private WebRtcEndpoint getEndpointForUser(final UserSession sender) {//메세지를 보낸 유저의 endPoint를 가져온다.
            if (sender.getName().equals(name)) {//메세지를 보낸사람이 자기 자신이면 자신의 endPoint를 반환
              log.debug("PARTICIPANT {}: configuring loopback", this.name);
              return outgoingMedia;
            }
        
            log.debug("PARTICIPANT {}: receiving video from {}", this.name, sender.getName());
        
            WebRtcEndpoint incoming = incomingMedia.get(sender.getName());//메세지보낸사람의 endPoint
            if (incoming == null) {//메세지 보낸사람의 endPoint가 없다면
              log.debug("PARTICIPANT {}: creating new endpoint for {}", this.name, sender.getName());
              incoming = new WebRtcEndpoint.Builder(pipeline).build();//endPoint를 생성한다.
        
              incoming.addIceCandidateFoundListener(new EventListener<IceCandidateFoundEvent>() {//생성된 endPoint에 대한 eventListener를 등록한다.
        
                @Override
                public void onEvent(IceCandidateFoundEvent event) {//이벤트 발생시 수행할 동작
                  JsonObject response = new JsonObject();
                  response.addProperty("id", "iceCandidate");
                  response.addProperty("name", sender.getName());
                  response.add("candidate", JsonUtils.toJsonObject(event.getCandidate()));
                  try {
                    synchronized (session) {//현재 session에 메세지를 보낸다.
                      session.sendMessage(new TextMessage(response.toString()));//현재 session에 접속해 있는 모든 유저에게 메세지 전송
                    }
                  } catch (IOException e) {
                    log.debug(e.getMessage());
                  }
                }
              });
        
              incomingMedia.put(sender.getName(), incoming);//현재 세션에 보낸사람의 endPoint연결?????
            }
        
            log.debug("PARTICIPANT {}: obtained endpoint for {}", this.name, sender.getName());
            sender.getOutgoingWebRtcPeer().connect(incoming);//나 자신의 세션에 보낸사람의 endPoint연결????????
        
            return incoming;
          }
        
          public void cancelVideoFrom(final UserSession sender) {
            this.cancelVideoFrom(sender.getName());
          }
        
          public void cancelVideoFrom(final String senderName) {
            log.debug("PARTICIPANT {}: canceling video reception from {}", this.name, senderName);
            final WebRtcEndpoint incoming = incomingMedia.remove(senderName);
        
            log.debug("PARTICIPANT {}: removing endpoint for {}", this.name, senderName);
            incoming.release(new Continuation<Void>() {
              @Override
              public void onSuccess(Void result) throws Exception {
                log.trace("PARTICIPANT {}: Released successfully incoming EP for {}",
                    UserSession.this.name, senderName);
              }
        
              @Override
              public void onError(Throwable cause) throws Exception {
                log.warn("PARTICIPANT {}: Could not release incoming EP for {}", UserSession.this.name,
                    senderName);
              }
            });
          }
        
          @Override
          public void close() throws IOException {
            log.debug("PARTICIPANT {}: Releasing resources", this.name);
            for (final String remoteParticipantName : incomingMedia.keySet()) {
        
              log.trace("PARTICIPANT {}: Released incoming EP for {}", this.name, remoteParticipantName);
        
              final WebRtcEndpoint ep = this.incomingMedia.get(remoteParticipantName);
        
              ep.release(new Continuation<Void>() {
        
                @Override
                public void onSuccess(Void result) throws Exception {
                  log.trace("PARTICIPANT {}: Released successfully incoming EP for {}",
                      UserSession.this.name, remoteParticipantName);
                }
        
                @Override
                public void onError(Throwable cause) throws Exception {
                  log.warn("PARTICIPANT {}: Could not release incoming EP for {}", UserSession.this.name,
                      remoteParticipantName);
                }
              });
            }
        
            outgoingMedia.release(new Continuation<Void>() {
        
              @Override
              public void onSuccess(Void result) throws Exception {
                log.trace("PARTICIPANT {}: Released outgoing EP", UserSession.this.name);
              }
        
              @Override
              public void onError(Throwable cause) throws Exception {
                log.warn("USER {}: Could not release outgoing EP", UserSession.this.name);
              }
            });
          }
        
          public void sendMessage(JsonObject message) throws IOException {
            log.debug("USER {}: Sending message {}", name, message);
            synchronized (session) {
              session.sendMessage(new TextMessage(message.toString()));
            }
          }
        
          public void addCandidate(IceCandidate candidate, String name) {
            if (this.name.compareTo(name) == 0) {//세션의 name과 파라미터의 name이 같으면
              outgoingMedia.addIceCandidate(candidate);//
            } else {
              WebRtcEndpoint webRtc = incomingMedia.get(name);
              if (webRtc != null) {
                webRtc.addIceCandidate(candidate);
              }
            }
          }
        
          /*
           * (non-Javadoc)
           *
           * @see java.lang.Object#equals(java.lang.Object)
           */
          @Override
          public boolean equals(Object obj) {
        
            if (this == obj) {
              return true;
            }
            if (obj == null || !(obj instanceof UserSession)) {
              return false;
            }
            UserSession other = (UserSession) obj;
            boolean eq = name.equals(other.name);
            eq &= roomName.equals(other.roomName);
            return eq;
          }
        
          /*
           * (non-Javadoc)
           *
           * @see java.lang.Object#hashCode()
           */
          @Override
          public int hashCode() {
            int result = 1;
            result = 31 * result + name.hashCode();
            result = 31 * result + roomName.hashCode();
            return result;
          }
        }
        ```